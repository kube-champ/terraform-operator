
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kube-champ/terraform-operator/api/v1alpha1/helpers.go (86.4%)</option>
				
				<option value="file1">github.com/kube-champ/terraform-operator/api/v1alpha1/k8s_configmaps.go (90.0%)</option>
				
				<option value="file2">github.com/kube-champ/terraform-operator/api/v1alpha1/k8s_helpers.go (100.0%)</option>
				
				<option value="file3">github.com/kube-champ/terraform-operator/api/v1alpha1/k8s_jobs.go (96.4%)</option>
				
				<option value="file4">github.com/kube-champ/terraform-operator/api/v1alpha1/k8s_rbac.go (76.5%)</option>
				
				<option value="file5">github.com/kube-champ/terraform-operator/api/v1alpha1/k8s_secrets.go (100.0%)</option>
				
				<option value="file6">github.com/kube-champ/terraform-operator/api/v1alpha1/terraform_template.go (71.4%)</option>
				
				<option value="file7">github.com/kube-champ/terraform-operator/api/v1alpha1/terraform_types.go (93.8%)</option>
				
				<option value="file8">github.com/kube-champ/terraform-operator/api/v1alpha1/zz_generated.deepcopy.go (18.5%)</option>
				
				<option value="file9">github.com/kube-champ/terraform-operator/controllers/terraform_controller.go (82.9%)</option>
				
				<option value="file10">github.com/kube-champ/terraform-operator/controllers/terraform_controller_operation.go (87.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package v1alpha1

import (
        "fmt"
        "math/rand"
        "strings"
)

// returns a bool on whether a string is available in a given array of string
func containsString(slice []string, s string) bool <span class="cov8" title="1">{
        for _, item := range slice </span><span class="cov8" title="1">{
                if item == s </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// removes a string from a given array of string
func removeString(slice []string, s string) (result []string) <span class="cov8" title="1">{
        for _, item := range slice </span><span class="cov8" title="1">{
                if item == s </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, item)</span>
        }
        <span class="cov8" title="1">return</span>
}

// generates a random alphanumeric based on the length provided
func random(n int) string <span class="cov8" title="1">{
        var letters = []rune("123456790abcdefghijklmnopqrstuvwxyz")

        b := make([]rune, n)

        for i := range b </span><span class="cov8" title="1">{
                b[i] = letters[rand.Intn(len(letters))]
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}

// returns common labels to be attached to children resources
func getCommonLabels(name string, runId string) map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "terraformRunName": name,
                "terraformRunId":   runId,
                "component":        "Terraform-run",
                "owner":            "run.terraform-operator.io",
        }
}</span>

func truncateResourceName(s string, i int) string <span class="cov8" title="1">{
        name := s
        if len(s) &gt; i </span><span class="cov0" title="0">{
                name = s[0:i]
                // End in alphanum, Assume only "-" and "." can be in name
                name = strings.TrimRight(name, "-")
                name = strings.TrimRight(name, ".")
        }</span>
        <span class="cov8" title="1">return name</span>
}

// creates a name for the terraform Run job
func getUniqueResourceName(name string, runId string) string <span class="cov8" title="1">{
        // return fmt.Sprintf("tf-apply-%s-%s", name, runId)

        return fmt.Sprintf("%s-%s", truncateResourceName(name, 220), runId)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package v1alpha1

import (
        "context"

        "github.com/kube-champ/terraform-operator/internal/kube"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
)

// creates a k8s ConifgMap for the terraform module string
// This configmap will be mounted in the pod so it can run the Terraform

func getConfigMapSpecForModule(name string, namespace string, module string, runId string, owner metav1.OwnerReference) *corev1.ConfigMap <span class="cov8" title="1">{
        cm := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      getUniqueResourceName(name, runId),
                        Namespace: namespace,
                        Labels:    getCommonLabels(name, runId),
                        OwnerReferences: []metav1.OwnerReference{
                                owner,
                        },
                },
                Data: map[string]string{
                        "main.tf": module,
                },
        }

        return cm
}</span>

func createConfigMapForModule(namespacedName types.NamespacedName, run *Terraform) (*corev1.ConfigMap, error) <span class="cov8" title="1">{
        configMaps := kube.ClientSet.CoreV1().ConfigMaps(namespacedName.Namespace)

        tpl, err := getTerraformModuleFromTemplate(run)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">configMap := getConfigMapSpecForModule(
                namespacedName.Name,
                namespacedName.Namespace,
                string(tpl), run.Status.RunId,
                run.GetOwnerReference())

        if _, err := configMaps.Create(context.TODO(), configMap, metav1.CreateOptions{}); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return configMap, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1alpha1

import (
        corev1 "k8s.io/api/core/v1"
)

// returns a volume spec
func getVolumeSpec(name string, source corev1.VolumeSource) corev1.Volume <span class="cov8" title="1">{
        return corev1.Volume{
                Name:         name,
                VolumeSource: source,
        }
}</span>

// returns a volume spec from configMap
func getVolumeSpecFromConfigMap(volumeName string, configMapName string) corev1.Volume <span class="cov8" title="1">{
        return corev1.Volume{
                Name: volumeName,
                VolumeSource: corev1.VolumeSource{
                        ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: configMapName,
                                },
                        },
                },
        }
}</span>

// returns and emptyDir volume spec
func getEmptyDirVolume(name string) corev1.Volume <span class="cov8" title="1">{
        return corev1.Volume{
                Name: name,
                VolumeSource: corev1.VolumeSource{
                        EmptyDir: &amp;corev1.EmptyDirVolumeSource{},
                },
        }
}</span>

// returns a volume mount spec
func getVolumeMountSpec(volumeName string, mountPath string, readOnly bool) corev1.VolumeMount <span class="cov8" title="1">{
        return corev1.VolumeMount{
                Name:      volumeName,
                MountPath: mountPath,
                ReadOnly:  readOnly,
        }
}</span>

// returns a volume mount spec with subpath option
func getVolumeMountSpecWithSubPath(volumeName string, mountPath string, subPath string, readOnly bool) corev1.VolumeMount <span class="cov8" title="1">{
        return corev1.VolumeMount{
                Name:      volumeName,
                MountPath: mountPath,
                ReadOnly:  readOnly,
                SubPath:   subPath,
        }
}</span>

func getEnvVariable(name string, value string) corev1.EnvVar <span class="cov8" title="1">{
        return corev1.EnvVar{
                Name:  name,
                Value: value,
        }
}</span>

func getEnvVariableFromFieldSelector(name string, path string) corev1.EnvVar <span class="cov8" title="1">{
        return corev1.EnvVar{
                Name: name,
                ValueFrom: &amp;corev1.EnvVarSource{
                        FieldRef: &amp;corev1.ObjectFieldSelector{
                                FieldPath: path,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package v1alpha1

import (
        "context"
        "fmt"
        "strconv"

        "github.com/kube-champ/terraform-operator/internal/kube"
        "github.com/kube-champ/terraform-operator/internal/utils"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        tfVarsMountPath           string = "/tmp/tfvars"
        moduleWorkingDirMountPath string = "/tmp/tfmodule"
        conifgMapModuleMountPath  string = "/terraform/modules"
        gitSSHKeyMountPath        string = "/root/.ssh"

        knownHostsVolumeName string = "known-hosts"
        emptyDirVolumeName   string = "tfmodule"
        gitSSHKeyVolumeName  string = "git-ssh"
)

func getTerraformRunnerDockerImage() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s:%s", utils.Env.DockerRepository, utils.Env.TerraformRunnerImage, utils.Env.TerraformRunnerImageTag)
}</span>

func getBusyboxDockerImage() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", utils.Env.DockerRepository, "busybox")
}</span>

// returns a string that could or could not start with a TF_VAR_ prefix for the container
func getEnvVarKey(v Variable) string <span class="cov8" title="1">{
        prefix := ""

        if !v.EnvironmentVariable </span><span class="cov8" title="1">{
                prefix = "TF_VAR_"
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s%s", prefix, v.Key)</span>
}

// returns a list of environment variables to injected to the job runner
// these environment variables are specific to the terraform runner container
func (t *Terraform) getRunnerSpecificEnvVars() []corev1.EnvVar <span class="cov8" title="1">{
        envVars := []corev1.EnvVar{}

        envVars = append(envVars, getEnvVariable("TERRAFORM_VERSION", t.Spec.TerraformVersion))
        envVars = append(envVars, getEnvVariable("TERRAFORM_WORKING_DIR", moduleWorkingDirMountPath))
        envVars = append(envVars, getEnvVariable("TERRAFORM_VAR_FILES_PATH", tfVarsMountPath))
        envVars = append(envVars, getEnvVariable("OUTPUT_SECRET_NAME", getUniqueResourceName(t.Name, t.Status.RunId)))
        envVars = append(envVars, getEnvVariable("TERRAFORM_DESTROY", strconv.FormatBool(t.Spec.Destroy)))

        envVars = append(envVars, getEnvVariableFromFieldSelector("POD_NAMESPACE", "metadata.namespace"))

        if t.Spec.Workspace != "" </span><span class="cov0" title="0">{
                envVars = append(envVars, getEnvVariable("TERRAFORM_WORKSPACE", t.Spec.Workspace))
        }</span>

        <span class="cov8" title="1">return envVars</span>
}

// returns Kubernetes Pod environment variables to be passed to the run job
func (t *Terraform) getEnvVariables() []corev1.EnvVar <span class="cov8" title="1">{
        vars := []corev1.EnvVar{}

        for _, v := range t.Spec.Variables </span><span class="cov8" title="1">{
                if v.ValueFrom != nil </span><span class="cov0" title="0">{
                        vars = append(vars, corev1.EnvVar{
                                Name:      getEnvVarKey(v),
                                ValueFrom: v.ValueFrom,
                        })
                }</span>

                <span class="cov8" title="1">if v.Value != "" </span><span class="cov8" title="1">{
                        vars = append(vars, corev1.EnvVar{
                                Name:  getEnvVarKey(v),
                                Value: v.Value,
                        })
                }</span>
        }

        <span class="cov8" title="1">vars = append(vars, t.getRunnerSpecificEnvVars()...)

        return vars</span>
}

func (t *Terraform) getRunnerSpecificVolumes() []corev1.Volume <span class="cov8" title="1">{
        volumes := []corev1.Volume{}

        name := getUniqueResourceName(t.Name, t.Status.RunId)

        volumes = append(volumes, getEmptyDirVolume(emptyDirVolumeName))
        volumes = append(volumes, getVolumeSpecFromConfigMap(name, name))

        if t.Spec.GitSSHKey != nil &amp;&amp; t.Spec.GitSSHKey.ValueFrom != nil </span><span class="cov8" title="1">{
                volumes = append(volumes, getVolumeSpec(gitSSHKeyVolumeName, *t.Spec.GitSSHKey.ValueFrom))
                volumes = append(volumes, getVolumeSpecFromConfigMap(knownHostsVolumeName, utils.Env.KnownHostsConfigMapName))
        }</span>

        <span class="cov8" title="1">return volumes</span>
}

// return the volumes to be mounted
func (t *Terraform) getJobVolumes() []corev1.Volume <span class="cov8" title="1">{
        volumes := []corev1.Volume{}

        for _, file := range t.Spec.VariableFiles </span><span class="cov8" title="1">{
                volumes = append(volumes, getVolumeSpec(file.Key, *file.ValueFrom))
        }</span>

        <span class="cov8" title="1">volumes = append(volumes, t.getRunnerSpecificVolumes()...)

        return volumes</span>
}

func (t *Terraform) getRunnerSpecificVolumeMounts() []corev1.VolumeMount <span class="cov8" title="1">{
        mounts := []corev1.VolumeMount{}

        mounts = append(mounts, getVolumeMountSpec(emptyDirVolumeName, moduleWorkingDirMountPath, false))
        mounts = append(mounts, getVolumeMountSpec(getUniqueResourceName(t.Name, t.Status.RunId), conifgMapModuleMountPath, false))

        if t.Spec.GitSSHKey != nil &amp;&amp; t.Spec.GitSSHKey.ValueFrom != nil </span><span class="cov8" title="1">{
                sshKeyFileName := "id_rsa"
                sshKnownHostsFileName := "known_hosts"

                sshKeyMountPath := fmt.Sprintf("%s/%s", gitSSHKeyMountPath, sshKeyFileName)
                sshKnownHostsMountPath := fmt.Sprintf("%s/%s", gitSSHKeyMountPath, sshKnownHostsFileName)

                mounts = append(mounts, getVolumeMountSpecWithSubPath(gitSSHKeyVolumeName, sshKeyMountPath, sshKeyFileName, false))
                mounts = append(mounts, getVolumeMountSpecWithSubPath(knownHostsVolumeName, sshKnownHostsMountPath, sshKnownHostsFileName, false))
        }</span>

        <span class="cov8" title="1">return mounts</span>
}

// return the volumes mounts
func (t *Terraform) getJobVolumeMounts() []corev1.VolumeMount <span class="cov8" title="1">{
        mounts := []corev1.VolumeMount{}

        for _, file := range t.Spec.VariableFiles </span><span class="cov8" title="1">{
                mountPath := fmt.Sprintf("%s/%s", tfVarsMountPath, file.Key)
                mounts = append(mounts, getVolumeMountSpec(file.Key, mountPath, true))
        }</span>

        <span class="cov8" title="1">mounts = append(mounts, t.getRunnerSpecificVolumeMounts()...)

        return mounts</span>
}

// returnrs the initContainers definition for the run job
func getInitContainersSpec(t *Terraform) []corev1.Container <span class="cov8" title="1">{
        containers := []corev1.Container{}

        cpModule := fmt.Sprintf("cp %s/main.tf %s/main.tf", conifgMapModuleMountPath, moduleWorkingDirMountPath)

        commands := []string{
                "/bin/sh",
                "-c",
        }

        args := []string{
                cpModule,
        }

        containers = append(containers, corev1.Container{
                Name:         "busybox",
                Image:        getBusyboxDockerImage(),
                VolumeMounts: t.getRunnerSpecificVolumeMounts(),
                Command:      commands,
                Args:         args,
        })

        return containers
}</span>

// returns a Kubernetes job struct to run the terraform
func getJobSpecForRun(t *Terraform, owner metav1.OwnerReference) *batchv1.Job <span class="cov8" title="1">{

        envVars := t.getEnvVariables()
        volumes := t.getJobVolumes()
        mounts := t.getJobVolumeMounts()

        job := &amp;batchv1.Job{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      getUniqueResourceName(t.Name, t.Status.RunId),
                        Namespace: t.Namespace,
                        Labels:    getCommonLabels(t.Name, t.Status.RunId),
                        OwnerReferences: []metav1.OwnerReference{
                                owner,
                        },
                },
                Spec: batchv1.JobSpec{
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: getCommonLabels(t.Name, t.Status.RunId),
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "terraform-runner",
                                        InitContainers:     getInitContainersSpec(t),
                                        Containers: []corev1.Container{
                                                {
                                                        Name:            "terraform",
                                                        Image:           getTerraformRunnerDockerImage(),
                                                        VolumeMounts:    mounts,
                                                        Env:             envVars,
                                                        ImagePullPolicy: corev1.PullIfNotPresent,
                                                },
                                        },
                                        Volumes:       volumes,
                                        RestartPolicy: corev1.RestartPolicyNever,
                                },
                        },
                },
        }

        job.Spec.BackoffLimit = &amp;t.Spec.RetryLimit

        return job
}</span>

// Gets the kubernetes job for a specific run
func getJobForRun(runName string, namespace string, runId string) (*batchv1.Job, error) <span class="cov8" title="1">{
        jobs := kube.ClientSet.BatchV1().Jobs(namespace)

        name := getUniqueResourceName(runName, runId)

        job, err := jobs.Get(context.Background(), name, metav1.GetOptions{})

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return job, err</span>
}

func createJobForRun(run *Terraform, configMap *corev1.ConfigMap, secret *corev1.Secret) (*batchv1.Job, error) <span class="cov8" title="1">{
        jobs := kube.ClientSet.BatchV1().Jobs(run.Namespace)

        ownerRef := run.GetOwnerReference()

        job := getJobSpecForRun(run, ownerRef)

        if _, err := jobs.Create(context.TODO(), job, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// Deletes the job run
func deleteJobByRun(runName string, namespace string, runId string) error <span class="cov8" title="1">{
        jobs := kube.ClientSet.BatchV1().Jobs(namespace)

        resourceName := getUniqueResourceName(runName, runId)

        deletePolicy := metav1.DeletePropagationForeground

        if err := jobs.Delete(context.Background(), resourceName, metav1.DeleteOptions{
                PropagationPolicy: &amp;deletePolicy,
        }); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package v1alpha1

import (
        "context"

        "github.com/kube-champ/terraform-operator/internal/kube"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func createServiceAccount(name string, namespace string) (*corev1.ServiceAccount, error) <span class="cov8" title="1">{
        key := &amp;corev1.ServiceAccount{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
        }

        sa, err := kube.ClientSet.CoreV1().ServiceAccounts(namespace).Create(context.Background(), key, metav1.CreateOptions{})

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return sa, nil</span>
}

func createRoleBinding(name string, namespace string) (*rbacv1.RoleBinding, error) <span class="cov8" title="1">{
        key := &amp;rbacv1.RoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                RoleRef: rbacv1.RoleRef{
                        Kind:     "ClusterRole",
                        Name:     name,
                        APIGroup: "rbac.authorization.k8s.io",
                },
                Subjects: []rbacv1.Subject{
                        rbacv1.Subject{
                                Kind:      "ServiceAccount",
                                Name:      name,
                                Namespace: namespace,
                        },
                },
        }

        role, err := kube.ClientSet.RbacV1().RoleBindings(namespace).Create(context.Background(), key, metav1.CreateOptions{})

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return role, nil</span>
}

func isServiceAccountExist(name string, namespace string) (bool, error) <span class="cov8" title="1">{
        _, err := kube.ClientSet.CoreV1().ServiceAccounts(namespace).Get(context.Background(), name, metav1.GetOptions{})

        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

func isRoleBindingExist(name string, namespace string) (bool, error) <span class="cov8" title="1">{
        _, err := kube.ClientSet.RbacV1().RoleBindings(namespace).Get(context.Background(), name, metav1.GetOptions{})

        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

func createRbacConfigIfNotExist(name string, namespace string) error <span class="cov8" title="1">{
        saExist, err := isServiceAccountExist(name, namespace)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">roleBindingExist, err := isRoleBindingExist(name, namespace)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !saExist &amp;&amp; !roleBindingExist </span><span class="cov8" title="1">{
                if _, err := createServiceAccount(name, namespace); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if _, err := createRoleBinding(name, namespace); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package v1alpha1

import (
        "context"

        "github.com/kube-champ/terraform-operator/internal/kube"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
)

// List all pods owned by the Run
func (t *Terraform) GetSecretById(namespacedName types.NamespacedName) (*corev1.Secret, error) <span class="cov8" title="1">{
        secrets := kube.ClientSet.CoreV1().Secrets(namespacedName.Namespace)

        name := getUniqueResourceName(namespacedName.Name, t.Status.RunId)

        secret, err := secrets.Get(context.Background(), name, metav1.GetOptions{})

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return secret, err</span>
}

func createSecretForOutputs(namespacedName types.NamespacedName, t *Terraform) (*corev1.Secret, error) <span class="cov8" title="1">{
        secrets := kube.ClientSet.CoreV1().Secrets(namespacedName.Namespace)

        secretName := getUniqueResourceName(namespacedName.Name, t.Status.RunId)

        obj := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:   secretName,
                        Labels: getCommonLabels(namespacedName.Name, t.Status.RunId),
                        OwnerReferences: []metav1.OwnerReference{
                                t.GetOwnerReference(),
                        },
                },
                Type: corev1.SecretTypeOpaque,
                Data: map[string][]byte{},
        }

        secret, err := secrets.Create(context.Background(), obj, metav1.CreateOptions{})

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return secret, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1alpha1

import (
        "bytes"
        "text/template"
)

func getTerraformModuleFromTemplate(run *Terraform) ([]byte, error) <span class="cov8" title="1">{
        tfTemplate, err := template.New("main.tf").Parse(`terraform {
                {{- if .Spec.Backend }}
                {{.Spec.Backend}}
                {{- end}}
        
                required_version = "~&gt; {{.Spec.TerraformVersion}}"
        }

        {{- if .Spec.ProvidersConfig }}
        {{.Spec.ProvidersConfig}}
        {{- end}}
        
        {{- range .Spec.Variables}}
        {{- if not .EnvironmentVariable }}
        variable "{{.Key}}" {}
        {{- end}}
        {{- end}}
        
        ## additional-blocks
        
        module "operator" {
                source = "{{.Spec.Module.Source}}"
                
                {{- if .Spec.Module.Version }}
                version = "{{.Spec.Module.Version}}"
                {{- end}}
        
                {{- range .Spec.Variables}}
                {{- if not .EnvironmentVariable }}
                {{.Key}} = var.{{.Key}}
                {{- end}}
                {{- end}}
        }
        
        {{- range .Spec.Outputs}}
        output "{{.Key}}" {
                value = module.operator.{{.ModuleOutputName}}
        }
        {{- end}}`)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var tpl bytes.Buffer

        if err := tfTemplate.Execute(&amp;tpl, run); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return tpl.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
)

// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

type Module struct {
        // module source, must be a valid Terraform module source
        Source string `json:"source"`
        // module version
        // +optional
        Version string `json:"version,omitempty"`
}

type VariableFile struct {
        // The module variable name
        Key string `json:"key"`

        // The source of the variable file
        ValueFrom *corev1.VolumeSource `json:"valueFrom"`
}

type Variable struct {
        // Terraform module variable name
        Key string `json:"key"`
        // Variable value
        // +optional
        Value string `json:"value"`
        // The variable value from a key source (secret or configmap)
        // +optional
        ValueFrom *corev1.EnvVarSource `json:"valueFrom,omitempty"`
        // EnvironmentVariable denotes if this variable should be created as environment variable
        // +optional
        EnvironmentVariable bool `json:"environmentVariable,omitempty"`
}

type Output struct {
        // Output key specifies the Kubernetes secret key
        // +optional
        Key string `json:"key"`
        // The output name as defined in the source Terraform module
        // +optional
        ModuleOutputName string `json:"moduleOutputName"`
}

// DependsOnSpec specifies the dependency on other Terraform runs
type DependsOn struct {
        // The Terraform object metadata.name
        Name string `json:"name"`
        // The namespace where the Terraform run exist
        // +optional
        Namespace string `json:"namespace,omitempty"`
}

type GitSSHKey struct {
        // The source of the value where the private SSH key exist
        ValueFrom *corev1.VolumeSource `json:"valueFrom"`
}

type TerraformRunStatus string

const (
        RunStarted              TerraformRunStatus = "Started"
        RunRunning              TerraformRunStatus = "Running"
        RunCompleted            TerraformRunStatus = "Completed"
        RunDestroyed            TerraformRunStatus = "Destroyed"
        RunFailed               TerraformRunStatus = "Failed"
        RunWaitingForDependency TerraformRunStatus = "WaitingForDependency"
)

// PreviousRuns stores the previous run information in case the current run object was modified
type PreviousRunStatus struct {
        // Attribute name in module
        // +optional
        RunId string `json:"id"`
        // Value
        // +optional
        Status TerraformRunStatus `json:"status"`
}

// TerraformSpec defines the desired state of Terraform
type TerraformSpec struct {
        // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
        // Important: Run "make" to regenerate code after modifying this file

        // The terraform version to use
        TerraformVersion string `json:"terraformVersion"`
        // The module information (source &amp; version)
        Module Module `json:"module"`
        // A custom terraform backend configuration
        // +optional
        Backend string `json:"backend,omitempty"`
        // A custom terraform providers configuration
        // +optional
        ProvidersConfig string `json:"providersConfig,omitempty"`
        // The terraform workspae. Defaults to `default`
        // +optional
        Workspace string `json:"workspace,omitempty"`
        // A list of dependencies on other Terraform runs
        // +optional
        DependsOn []*DependsOn `json:"dependsOn,omitempty"`
        // Variables as inputs to the Terraform module
        // +optional
        Variables []Variable `json:"variables,omitempty"`
        // Terraform variable files
        // +optional
        VariableFiles []VariableFile `json:"variableFiles,omitempty"`
        // Terraform outputs will be written to a Kubernetes secret
        // +optional
        Outputs []*Output `json:"outputs,omitempty"`
        // Indicates whether a destroy job should run
        // +optional
        Destroy bool `json:"destroy,omitempty"`
        // Indicates whether to keep the jobs/pods after the run is successful/completed
        // +optional
        DeleteCompletedJobs bool `json:"deleteCompletedJobs,omitempty"`
        // A retry limit to be set on the Job as a backOffLimit
        // +optional
        RetryLimit int32 `json:"retryLimit,omitempty"`
        // An SSH key to be able to pull modules from private git repositories
        // +optional
        GitSSHKey *GitSSHKey `json:"gitSSHKey,omitempty"`
}

// TerraformStatus defines the observed state of Terraform
type TerraformStatus struct {
        // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
        // Important: Run "make" to regenerate code after modifying this file

        RunId              string              `json:"currentRunId"`
        PreviousRuns       []PreviousRunStatus `json:"previousRuns,omitempty"`
        ObservedGeneration int64               `json:"observedGeneration"`
        RunStatus          TerraformRunStatus  `json:"runStatus"`
        Message            string              `json:"message,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// Terraform is the Schema for the terraforms API
// +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.runStatus"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
type Terraform struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TerraformSpec   `json:"spec,omitempty"`
        Status TerraformStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// TerraformList contains a list of Terraform
type TerraformList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Terraform `json:"items"`
}

// this evaluate the first time the object was created
func (t *Terraform) IsSubmitted() bool <span class="cov8" title="1">{
        return t.Status.ObservedGeneration == 0 &amp;&amp; t.Status.RunId == ""
}</span>

// the run is either started or running
func (t *Terraform) IsStarted() bool <span class="cov8" title="1">{
        allowedStatuses := map[TerraformRunStatus]bool{
                RunStarted: true,
                RunRunning: true,
        }

        return allowedStatuses[t.Status.RunStatus]
}</span>

// check if the status is running
func (t *Terraform) IsRunning() bool <span class="cov8" title="1">{
        return t.Status.RunStatus == RunRunning
}</span>

// check if the object was updated
func (t *Terraform) IsUpdated() bool <span class="cov8" title="1">{
        return t.Generation &gt; 0 &amp;&amp; t.Generation &gt; t.Status.ObservedGeneration
}</span>

// check if the run is waiting
func (t *Terraform) IsWaiting() bool <span class="cov8" title="1">{
        return t.Status.RunStatus == RunWaitingForDependency
}</span>

func (t *Terraform) HasErrored() bool <span class="cov8" title="1">{
        return t.Status.RunStatus == RunFailed
}</span>

func (r *Terraform) SetRunId() <span class="cov8" title="1">{
        r.Status.RunId = random(8)
}</span>

func (t *Terraform) PrepareForUpdate() <span class="cov8" title="1">{
        if len(t.Status.PreviousRuns) == 0 </span><span class="cov8" title="1">{
                t.Status.PreviousRuns = []PreviousRunStatus{}
        }</span>

        <span class="cov8" title="1">t.Status.PreviousRuns = append(t.Status.PreviousRuns, PreviousRunStatus{
                RunId:  t.Status.RunId,
                Status: t.Status.RunStatus,
        })</span>
}

// GetOwnerReference returns the owner reference
func (t *Terraform) GetOwnerReference() metav1.OwnerReference <span class="cov8" title="1">{
        return metav1.OwnerReference{
                APIVersion: fmt.Sprintf("%s/%s", GroupVersion.Group, GroupVersion.Version),
                Kind:       t.Kind,
                Name:       t.Name,
                UID:        t.GetUID(),
        }
}</span>

const runnerRBACName string = "terraform-runner"

// CreateTerraformRun creates a job to execute the terraform module
func (t *Terraform) CreateTerraformRun(namespacedName types.NamespacedName) (*batchv1.Job, error) <span class="cov8" title="1">{
        if err := createRbacConfigIfNotExist(runnerRBACName, namespacedName.Namespace); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">configMap, err := createConfigMapForModule(namespacedName, t)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">secret, err := createSecretForOutputs(namespacedName, t)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">job, err := createJobForRun(t, configMap, secret)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

func (t *Terraform) DeleteAfterCompletion() error <span class="cov8" title="1">{
        if err := deleteJobByRun(t.Name, t.Namespace, t.Status.RunId); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *Terraform) GetJobByRun() (*batchv1.Job, error) <span class="cov8" title="1">{
        job, err := getJobForRun(t.Name, t.Namespace, t.Status.RunId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return job, err</span>
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;Terraform{}, &amp;TerraformList{})
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
        "k8s.io/api/core/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DependsOn) DeepCopyInto(out *DependsOn) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DependsOn.
func (in *DependsOn) DeepCopy() *DependsOn <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DependsOn)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitSSHKey) DeepCopyInto(out *GitSSHKey) <span class="cov0" title="0">{
        *out = *in
        if in.ValueFrom != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ValueFrom, &amp;out.ValueFrom
                *out = new(v1.VolumeSource)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitSSHKey.
func (in *GitSSHKey) DeepCopy() *GitSSHKey <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GitSSHKey)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Module) DeepCopyInto(out *Module) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Module.
func (in *Module) DeepCopy() *Module <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Module)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Output) DeepCopyInto(out *Output) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Output.
func (in *Output) DeepCopy() *Output <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Output)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PreviousRunStatus) DeepCopyInto(out *PreviousRunStatus) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PreviousRunStatus.
func (in *PreviousRunStatus) DeepCopy() *PreviousRunStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(PreviousRunStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Terraform) DeepCopyInto(out *Terraform) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Terraform.
func (in *Terraform) DeepCopy() *Terraform <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(Terraform)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Terraform) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformList) DeepCopyInto(out *TerraformList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]Terraform, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformList.
func (in *TerraformList) DeepCopy() *TerraformList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(TerraformList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TerraformList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformSpec) DeepCopyInto(out *TerraformSpec) <span class="cov8" title="1">{
        *out = *in
        out.Module = in.Module
        if in.DependsOn != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DependsOn, &amp;out.DependsOn
                *out = make([]*DependsOn, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(DependsOn)
                                **out = **in
                        }</span>
                }
        }
        <span class="cov8" title="1">if in.Variables != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Variables, &amp;out.Variables
                *out = make([]Variable, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.VariableFiles != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.VariableFiles, &amp;out.VariableFiles
                *out = make([]VariableFile, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.Outputs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Outputs, &amp;out.Outputs
                *out = make([]*Output, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(Output)
                                **out = **in
                        }</span>
                }
        }
        <span class="cov8" title="1">if in.GitSSHKey != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.GitSSHKey, &amp;out.GitSSHKey
                *out = new(GitSSHKey)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformSpec.
func (in *TerraformSpec) DeepCopy() *TerraformSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(TerraformSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformStatus) DeepCopyInto(out *TerraformStatus) <span class="cov8" title="1">{
        *out = *in
        if in.PreviousRuns != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PreviousRuns, &amp;out.PreviousRuns
                *out = make([]PreviousRunStatus, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformStatus.
func (in *TerraformStatus) DeepCopy() *TerraformStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(TerraformStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Variable) DeepCopyInto(out *Variable) <span class="cov8" title="1">{
        *out = *in
        if in.ValueFrom != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ValueFrom, &amp;out.ValueFrom
                *out = new(v1.EnvVarSource)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Variable.
func (in *Variable) DeepCopy() *Variable <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Variable)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VariableFile) DeepCopyInto(out *VariableFile) <span class="cov0" title="0">{
        *out = *in
        if in.ValueFrom != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ValueFrom, &amp;out.ValueFrom
                *out = new(v1.VolumeSource)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VariableFile.
func (in *VariableFile) DeepCopy() *VariableFile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VariableFile)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"

        "github.com/go-logr/logr"
        "github.com/kube-champ/terraform-operator/api/v1alpha1"
)

// TerraformReconciler reconciles a Terraform object
type TerraformReconciler struct {
        client.Client
        Scheme   *runtime.Scheme
        Recorder record.EventRecorder
        Log      logr.Logger
}

//+kubebuilder:rbac:groups=run.terraform-operator.io,resources=terraforms,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=run.terraform-operator.io,resources=terraforms/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=run.terraform-operator.io,resources=terraforms/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the Terraform object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.10.0/pkg/reconcile
func (r *TerraformReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        run := &amp;v1alpha1.Terraform{}
        start := time.Now()
        durationMsg := fmt.Sprintf("reconcilation finished in %s", time.Now().Sub(start).String())

        if err := r.Get(ctx, req.NamespacedName, run); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">if run.IsSubmitted() || run.IsWaiting() </span><span class="cov8" title="1">{
                result, err := r.create(run, req.NamespacedName)

                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if result.RequeueAfter &gt; 0 </span><span class="cov8" title="1">{
                        r.Log.Info(fmt.Sprintf("%s, next run in %s", durationMsg, result.RequeueAfter.String()))

                        return result, nil
                }</span>

                <span class="cov8" title="1">r.Recorder.Event(run, "Normal", "Created", fmt.Sprintf("Run(%s) submitted", run.Status.RunId))

                return result, nil</span>
        }

        <span class="cov8" title="1">if run.IsStarted() </span><span class="cov8" title="1">{
                result, err := r.watchRun(run, req.NamespacedName)

                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if result.RequeueAfter &gt; 0 </span><span class="cov8" title="1">{
                        r.Log.Info(fmt.Sprintf("%s, next run in %s", durationMsg, result.RequeueAfter.String()))

                        return result, nil
                }</span>

                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">if run.IsUpdated() </span><span class="cov8" title="1">{
                r.Log.Info("updating a terraform run")

                result, err := r.update(run, req.NamespacedName)

                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if result.RequeueAfter &gt; 0 </span><span class="cov0" title="0">{
                        r.Log.Info(fmt.Sprintf("%s, next run in %s", durationMsg, result.RequeueAfter.String()))

                        return result, nil
                }</span>

                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *TerraformReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.Terraform{}).
                Owns(&amp;batchv1.Job{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package controllers

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/kube-champ/terraform-operator/api/v1alpha1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

var (
        requeueJobWatch   time.Duration = 20 * time.Second
        requeueDependency time.Duration = 25 * time.Second
)

func updateRunStatus(r *TerraformReconciler, run *v1alpha1.Terraform, status v1alpha1.TerraformRunStatus) <span class="cov8" title="1">{
        run.Status.RunStatus = status
        r.Status().Update(context.Background(), run)
}</span>

func (r *TerraformReconciler) create(run *v1alpha1.Terraform, namespacedName types.NamespacedName) (ctrl.Result, error) <span class="cov8" title="1">{
        err := r.checkDependencies(*run)

        run.Status.ObservedGeneration = run.Generation

        if err != nil </span><span class="cov8" title="1">{
                if !run.IsWaiting() </span><span class="cov8" title="1">{
                        r.Recorder.Event(run, "Normal", "Waiting", "Dependencies are not yet completed")
                        updateRunStatus(r, run, v1alpha1.RunWaitingForDependency)
                }</span>

                <span class="cov8" title="1">return ctrl.Result{
                        RequeueAfter: requeueDependency,
                }, nil</span>
        }

        <span class="cov8" title="1">run.SetRunId()

        _, err = run.CreateTerraformRun(namespacedName)

        if err != nil </span><span class="cov0" title="0">{
                r.Log.Error(err, "failed create a terraform run")

                updateRunStatus(r, run, v1alpha1.RunFailed)

                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">updateRunStatus(r, run, v1alpha1.RunStarted)

        return ctrl.Result{}, nil</span>
}

func (r *TerraformReconciler) update(run *v1alpha1.Terraform, namespacedName types.NamespacedName) (ctrl.Result, error) <span class="cov8" title="1">{
        run.PrepareForUpdate()

        r.Recorder.Event(run, "Normal", "Updated", "Creating a new run job")

        return r.create(run, namespacedName)
}</span>

func (r *TerraformReconciler) watchRun(run *v1alpha1.Terraform, namespacedName types.NamespacedName) (ctrl.Result, error) <span class="cov8" title="1">{
        job, err := run.GetJobByRun()

        r.Log.Info("watching job run to complete", "name", job.Name)

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // job hasn't started
        <span class="cov8" title="1">if job.Status.Active == 0 &amp;&amp; job.Status.Succeeded == 0 &amp;&amp; job.Status.Failed == 0 </span><span class="cov8" title="1">{
                return ctrl.Result{RequeueAfter: requeueJobWatch}, nil
        }</span>

        // job is still running
        <span class="cov8" title="1">if job.Status.Active &gt; 0 </span><span class="cov8" title="1">{
                if !run.IsRunning() </span><span class="cov8" title="1">{
                        updateRunStatus(r, run, v1alpha1.RunRunning)

                        r.Recorder.Event(run, "Normal", "Running", fmt.Sprintf("Run(%s) waiting for run job to finish", run.Status.RunId))
                }</span>

                <span class="cov8" title="1">return ctrl.Result{RequeueAfter: requeueJobWatch}, nil</span>
        }

        // job is successful
        <span class="cov8" title="1">if job.Status.Succeeded &gt; 0 </span><span class="cov8" title="1">{
                r.Log.Info("terraform run job completed successfully")

                if run.Spec.DeleteCompletedJobs </span><span class="cov8" title="1">{
                        r.Log.Info("deleting completed job")

                        if err := run.DeleteAfterCompletion(); err != nil </span><span class="cov0" title="0">{
                                r.Log.Error(err, "failed to delete run job after completion", "name", job.Name)
                        }</span> else<span class="cov8" title="1"> {
                                r.Recorder.Event(run, "Normal", "Cleanup", fmt.Sprintf("Run(%s) kubernetes job was deleted", run.Status.RunId))
                        }</span>
                }

                <span class="cov8" title="1">if !run.Spec.Destroy </span><span class="cov8" title="1">{
                        r.Recorder.Event(run, "Normal", "Completed", fmt.Sprintf("Run(%s) completed", run.Status.RunId))
                }</span> else<span class="cov8" title="1"> {
                        r.Recorder.Event(run, "Normal", "Destroyed", fmt.Sprintf("Run(%s) completed with terraform destroy", run.Status.RunId))
                }</span>

                <span class="cov8" title="1">updateRunStatus(r, run, v1alpha1.RunCompleted)

                return ctrl.Result{}, nil</span>
        }

        // if it got here, then the job is failed -- sadly .... :( :( :(
        <span class="cov8" title="1">r.Recorder.Event(run, "Warning", "Failed", fmt.Sprintf("Run(%s) failed", run.Status.RunId))
        r.Log.Error(errors.New("job failed"), "terraform run job failed to complete", "name", job.Name)

        updateRunStatus(r, run, v1alpha1.RunFailed)

        return ctrl.Result{}, nil</span>
}

func (r *TerraformReconciler) checkDependencies(run v1alpha1.Terraform) error <span class="cov8" title="1">{
        for _, d := range run.Spec.DependsOn </span><span class="cov8" title="1">{

                if d.Namespace == "" </span><span class="cov0" title="0">{
                        d.Namespace = run.Namespace
                }</span>

                <span class="cov8" title="1">dName := types.NamespacedName{
                        Namespace: d.Namespace,
                        Name:      d.Name,
                }

                var dRun v1alpha1.Terraform

                err := r.Get(context.Background(), dName, &amp;dRun)

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to get '%s' dependency: %w", dName, err)
                }</span>

                <span class="cov8" title="1">if dRun.Status.RunStatus != v1alpha1.RunCompleted </span><span class="cov8" title="1">{
                        return fmt.Errorf("dependency '%s' is not ready", dName)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
